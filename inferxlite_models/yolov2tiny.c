/*
	This file is generated by net_compiler.py.
	The use of included functions list as follows:

	Input:
	inferx_input(int *shape, void *pdata, char *top,char *name,char *model_pre,char *data_pre,struct inferx_handler *hd)
	

	Convolution:
	inferx_convolution(int num_input,int num_output,int kernel_h,int kernel_w,int stride_h,int stride_w,int pad_h,int pad_w,int group,int dilation,int axis,bool bias_term,bool force_nd_im2col,char *bottom,char *top, char *name,char *model_pre, char *data_pre, int activation_type, float negative_slope, struct inferx_handler *hd)
	

	BatchNorm:
	inferx_batchnorm(float moving_average_fraction,float eps,bool use_global_stats,char *bottom,char *top,char *name, char *model_pre, char *data_pre, struct inferx_handler *hd)

	Scale:
	inferx_scale(int axis,int num_axes,bool bias_term,char *bottom,char *top,char *name, char *model_pre, char *data_pre, struct inferx_handler *hd)

	ReLU:
	inferx_relu(float slope, char *bottom,char *top,char *name, char *model_pre, char *data_pre, struct inferx_handler *hd)

	Pooling:
	inferx_pooling(int kernel_h,int kernel_w,int stride_h,int stride_w,int pad_h,int pad_w,char *pool_mode,char *bottom,char *top,char *name,char *model_pre, char *data_pre, struct inferx_handler *hd)
	

	Region:
	Region(int number, int classes, int coords, char * bottom, char *top, char *name,char *model_pre, char *data_pre, struct inferx_handler *hd)
*/


#include "interface.h"
#include "quantization.h"
#include <stdbool.h>

struct inferx_handler;
void yolov2tiny(char* path, char* model, char* data, int *shape, int nshape, void* pdata, void** pout,int *len, struct inferx_handler *hd)
{
	inferx_net_preprocess(data,model,hd);

	inferx_input(shape,pdata,"data_data","data",model,data,hd);
	inferx_convolution(3,16,3,3,1,1,1,1,1,1,1,true,false,"data_data","layer1-conv_data","layer1-conv",model,data, 1, 0.1, hd);
	inferx_pooling(2,2,2,2,0,0,"MAX","layer1-conv_data","layer2-maxpool_data","layer2-maxpool",model,data,hd);
	
	inferx_convolution(16,32,3,3,1,1,1,1,1,1,1,true,false,"layer2-maxpool_data","layer3-conv_data","layer3-conv",model,data, 1, 0.1, hd);
	inferx_pooling(2,2,2,2,0,0,"MAX","layer3-conv_data","layer4-maxpool_data","layer4-maxpool",model,data,hd);
	
	inferx_convolution(32,64,3,3,1,1,1,1,1,1,1,true,false,"layer4-maxpool_data","layer5-conv_data","layer5-conv",model,data, 1, 0.1, hd);
	inferx_pooling(2,2,2,2,0,0,"MAX","layer5-conv_data","layer6-maxpool_data","layer6-maxpool",model,data,hd);
	
	inferx_convolution(64,128,3,3,1,1,1,1,1,1,1,true,false,"layer6-maxpool_data","layer7-conv_data","layer7-conv",model,data, 1, 0.1, hd);
	inferx_pooling(2,2,2,2,0,0,"MAX","layer7-conv_data","layer8-maxpool_data","layer8-maxpool",model,data,hd);
	
	inferx_convolution(128,256,3,3,1,1,1,1,1,1,1,true,false,"layer8-maxpool_data","layer9-conv_data","layer9-conv",model,data, 1, 0.1, hd);
	inferx_pooling(2,2,2,2,0,0,"MAX","layer9-conv_data","layer10-maxpool_data","layer10-maxpool",model,data,hd);
	
	inferx_convolution(256,512,3,3,1,1,1,1,1,1,1,true,false,"layer10-maxpool_data","layer11-conv_data","layer11-conv",model,data, 1, 0.1, hd);
	inferx_pooling(2,2,1,1,1,1,"MAX","layer11-conv_data","layer12-maxpool_data","layer12-maxpool",model,data,hd);
	
	inferx_convolution(512,1024,3,3,1,1,1,1,1,1,1,true,false,"layer12-maxpool_data","layer13-conv_data","layer13-conv",model,data, 1, 0.1, hd);
	inferx_convolution(1024,512,3,3,1,1,1,1,1,1,1,true,false,"layer13-conv_data","layer14-conv_data","layer14-conv",model,data, 1, 0.1, hd);
	inferx_convolution(512,35,1,1,1,1,0,0,1,1,1,true,false,"layer14-conv_data","layer15-conv_data","layer15-conv",model,data, 0, 0, hd);
	//inferx_region(5,2,4,"layer15-conv_data","layer16-region_data","layer16-region",model,data,hd);

	// only one output feature map 
	//inferx_sort_data("layer16-region_data",data);
	//inferx_print_data("layer16-region_data",data);
	//if(pout)
	  //*pout = inferx_get_data("layer16-region_data",data,len,hd);
	inferx_finalize("yolov2tiny",hd);

	return;
}
