/*
	This file is generated by net_compiler.py.
	The use of included functions list as follows:

	Input:
	inferx_input(int *shape, void *pdata, char *top,char *name,char *model_pre,char *data_pre,struct inferx_handler *hd)
	

	Convolution:
	inferx_convolution(int num_input,int num_output,int kernel_h,int kernel_w,int stride_h,int stride_w,int pad_h,int pad_w,int group,int dilation,int axis,bool bias_term,bool force_nd_im2col,char *bottom,char *top, char *name,char *model_pre, char *data_pre, int activation_type, float negative_slope, struct inferx_handler *hd)
	

	BatchNorm:
	inferx_batchnorm(float moving_average_fraction,float eps,bool use_global_stats,char *bottom,char *top,char *name, char *model_pre, char *data_pre, struct inferx_handler *hd)

	Scale:
	inferx_scale(int axis,int num_axes,bool bias_term,char *bottom,char *top,char *name, char *model_pre, char *data_pre, struct inferx_handler *hd)

	ReLU:
	inferx_relu(float slope, char *bottom,char *top,char *name, char *model_pre, char *data_pre, struct inferx_handler *hd)

	Pooling:
	inferx_pooling(int kernel_h,int kernel_w,int stride_h,int stride_w,int pad_h,int pad_w,char *pool_mode,char *bottom,char *top,char *name,char *model_pre, char *data_pre, struct inferx_handler *hd)
	

	InnerProduct:
	inferx_inner_product(int num_input,int num_output,bool bias_term,bool transpose,char *bottom,char *top,char *name,char *model_pre, char *data_pre, struct inferx_handler *hd)
*/


#include "interface.h"
#include <stdbool.h>
struct inferx_handler;
void FaceLandmark(char* path, char* model, char* data, int *shape, int nshape, void* pdata, void** pout,int *len, struct inferx_handler *hd)
{
	inferx_net_preprocess(data,model,hd);

	inferx_input(shape,pdata,"data_data","data",model,data,hd);
	inferx_convolution(3,32,3,3,1,1,1,1,1,1,1,true,false,"data_data","conv1_1_scale_data","conv1_1",model,data, 1, 0.0, hd);
	inferx_pooling(2,2,2,2,0,0,"MAX","conv1_1_scale_data","pool1_data","pool1",model,data,hd);
	
	inferx_convolution(32,32,3,3,1,1,1,1,1,1,1,true,false,"pool1_data","conv2_1_scale_data","conv2_1",model,data, 1, 0.0, hd);
	inferx_pooling(2,2,2,2,0,0,"MAX","conv2_1_scale_data","pool2_data","pool2",model,data,hd);
	
	inferx_convolution(32,64,3,3,1,1,1,1,1,1,1,true,false,"pool2_data","conv3_1_scale_data","conv3_1",model,data, 1, 0.0, hd);
	inferx_pooling(2,2,2,2,0,0,"MAX","conv3_1_scale_data","pool3_data","pool3",model,data,hd);
	
	inferx_convolution(64,64,3,3,1,1,1,1,1,1,1,true,false,"pool3_data","conv4_1_scale_data","conv4_1",model,data, 1, 0.0, hd);
	inferx_pooling(2,2,2,2,0,0,"MAX","conv4_1_scale_data","pool4_data","pool4",model,data,hd);
	
	inferx_inner_product(64,64,true,false,"pool4_data","ip1_data","ip1_finetune",model,data,hd);
	inferx_batchnorm(0.9,1e-5,true,"ip1_data","ip1_bn_data","ip1_bn",model,data,hd);
	inferx_scale(1,1,true,"ip1_bn_data","ip1_scale_data","ip1_scale",model,data,hd);
	inferx_relu(0.0,"ip1_scale_data","ip1_scale_data","relu_ip1",model,data,hd);
	inferx_inner_product(64,10,true,false,"ip1_scale_data","ip2_data","ip2_finetune",model,data,hd);
	inferx_batchnorm(0.9,1e-5,true,"ip2_data","ip2_bn_data","ip2_bn",model,data,hd);
	inferx_scale(1,1,true,"ip2_bn_data","ip2_scale_data","ip2_scale",model,data,hd);

	// only one output feature map 
	//inferx_sort_data("ip2_scale_data",data);
	//inferx_print_data("ip2_scale_data",data);
	//if(pout)
	  //*pout = inferx_get_data("ip2_scale_data",data,len,hd);
	inferx_finalize("FaceLandmark",hd);

	return;
}
